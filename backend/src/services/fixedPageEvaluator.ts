/**
 * @fileoverview Performs accessibility evaluation on page after LLM code generation
 * @author Ruoqian Zhang
 * @copyright 2024 Accessible UI Helper. All rights reserved.
 */

import axe, { AxeResults, Result } from 'axe-core';
import { JSDOM } from 'jsdom';
import { GeneratedFilesInfo, FileCollection} from '../models/models';
import { logging } from '../lib/logging';


const logger = logging.getLogger('services.fixedPageEvaluator');

export class FixedPageEvaluator {

    //llm generated format
    private generatedFilesInfo: GeneratedFilesInfo;
    // the data which pass to the llm
    private fileCollection :FileCollection;

    constructor(fileCollection: FileCollection, generatedPage: GeneratedFilesInfo) {
        this.generatedFilesInfo = generatedPage;
        this.fileCollection = fileCollection
    }

    /**
     * Generates the DOM tree from the input HTML
     * @param inputHtml String of html content
     * @returns 
     */
    private generateDOMFromHtml(inputHtml: string): Document {
        const { document } = new JSDOM(inputHtml).window;
        return document;
    }

    /**
     * Retrieves the Axe accessibility results from HTML page
     * @returns the accessibility results object
     */
    private async getAxeResults(generatedPage: string): Promise<AxeResults> {
        try {

            const document: Document = this.generateDOMFromHtml(generatedPage);

            axe.setup(document);
            const axeResults = await axe.run(document);

            logger.info('Retrieved Axe Core evaluation.')

            return axeResults;
        } catch (error) {
            logger.error(`An error occurred ${error}`);
            throw error;
        }
        
    }

    /**
     * Determine if there are any failed violations.
     * @param originalViolations Axe violations returned by the frontend
     * @param newViolations Axe violations generated by the backend evaluation
     * @returns the vialations which failed to fix
     */
    private compare(originalViolations: Array<Object>, newViolations: Array<Result>): any{

        const extractedViolations: { target: string | object; targetCode: string; message: string }[] = [];


        // Iterate through the violations array and extract the same data structure as the originalViolations
        newViolations.forEach(violation => {
            if (violation.nodes && Array.isArray(violation.nodes)) {
                violation.nodes.forEach(node => {
                    if (node.html && node.failureSummary) {
                        extractedViolations.push({
                         target : node.target[0],
                         targetCode: node.html,
                         message: node.failureSummary
                     });
                }
                });
            }
        });
        
        // mock the the process that failed the evaluation test.

       /*extractedViolations.length = 0;

       extractedViolations.push(
            {
                target: "html",
                targetCode: "<html>",
                message: "Fix any of the following:\n The <html> element does not have a lang attribute"
            },
            {
                target: "h1",
                targetCode: "<h1>Home Page Updated</h1>",
                message: "Fix any of the following:\n  Some page content is not contained by landmarks"
            }
        );

        console.log("Updated extractedViolations:", extractedViolations);*/


        // find which violation failed to fix
        const intersection =originalViolations.filter(item1 =>
            extractedViolations.some(item2 => JSON.stringify(item1) === JSON.stringify(item2))
        );

        return intersection.length > 0 ? intersection : null;
       
    }

    /**
     * generate the new fileCollection with failed violation
     * @param Page file name
     * @param FailedViolation Axe violations which failed to pass
     * @param fileCollection which need to pass to the LLM
     * @param generatedFilesInfo The LLM output
     * @returns mnew fileCollection
     */
    private generateFailedInput(Page: string, FailedViolation: any, fileCollection:FileCollection, generatedFilesInfo: GeneratedFilesInfo): any{
        //update fileCollection's htmlWithInlineScripts to new htmlWithInlineScripts

        fileCollection[Page].htmlWithInlineScripts = generatedFilesInfo.generatedCode[Page].htmlWithInlineScripts;
        fileCollection[Page].content = generatedFilesInfo.generatedCode[Page].content;

        //Leave only the duplicates and delete the rest.
        if (fileCollection && fileCollection[Page]) {
            fileCollection[Page].violationInfo = FailedViolation;
          }

       return fileCollection
  
    }

    /**
    * Main class method
    * @returns A boolean value to determine success or failure: if successful,
    * return GeneratedFilesInfo; if not, return NewFileCollection to allow the LLM to run again.
    */

    public async evaluatePage(): Promise<any>  {

        //original code
        const originalDataCollection = this.generatedFilesInfo.originalData

        // generatedPage is file name which has violation
        // find which file has violation    
        const htmlWithViolations = Object.keys(originalDataCollection).filter(key => {
            const item = originalDataCollection[key];
            return key.endsWith('.html') && Array.isArray(item.violationInfo) && item.violationInfo.length > 0;
          });

        //Extracts the originalViolation for comparison with the new one.
        const oldViolations = this.generatedFilesInfo.originalData[htmlWithViolations[0]]?.violationInfo?.map(violation => ({
            target: violation.target,
            targetCode: violation.targetCode,
            message: violation.message
        })) || [];
        
  
        //Put the modified htmlInlineCssJs into axecore and run it.
        const generatedCode = this.generatedFilesInfo.generatedCode[htmlWithViolations[0]];
        const res = await this.getAxeResults(generatedCode.htmlWithInlineScripts?? '')

        const FailedViolation = this.compare(oldViolations, res.violations)


        //Pass the evaluation
        if (FailedViolation == null){
            return {success: true, 
                result: this.generatedFilesInfo}}
        
        //Generate a new filecollection to call llm again.
        const NewfileCollection = this.generateFailedInput(htmlWithViolations[0],FailedViolation, this.fileCollection, this.generatedFilesInfo)
        return {success: false, 
            result: NewfileCollection}}

        
    }
