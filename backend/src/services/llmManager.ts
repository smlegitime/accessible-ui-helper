/**
 * Description: Performs fixes on a page based on an accessibility report using an LLM
 * Created: Rio Young
 * Created date: Oct 22, 2024 | Updated date: 11/7/24
 */

import {GeneratedFilesInfo, FileData, AccViolation, FileCollection, FixedFileCollection } from '../models/models';
import OpenAI from "openai";
import * as dotenv from 'dotenv';




import './errorHandler';
import { content } from 'pdfkit/js/page';
import { file } from 'pdfkit';

// PromptBuilder
// Retrieve prompt template
// Add few-shot examples (from scanned results)
// Configure LLM call
// Make request
// Update data with new code
// (Store data)
// (FixedPageEvaluator?)

// llm sample output
// ```html
// <!DOCTYPE html>
// <html>
//   <head>
//     <title>Home Page Updated</title>
//     <link rel="stylesheet" href="style.css">
//   </head>
//   <body>
//     <h1>Home Page Updated</h1>
//     <main>
//       <button id="btn">Click Me</button>
//       <a href="about.html">Go to About</a>
//     </main>
//     <script src="node_modules/axe-core/axe.min.js"></script>
//     <script src="script.js"></script>
//     <script src="axe-script.js"></script>
//   </body>
// </html>
// ```
let test_output_string = "```html\n\
<!DOCTYPE html>\n\
<html>\n\
  <head>\n\
    <title>Home Page Updated</title>\n\
    <link rel=\"stylesheet\" href=\"style.css\">\n\
  </head>\n\
  <body>\n\
    <header>\n\
      <h1>Home Page Updated</h1>\n\
    </header>\n\
    <main>\n\
      <button id=\"btn\">Click Me</button>\n\
      <a href=\"about.html\">Go to About</a>\n\
    </main>\n\
    <script src=\"node_modules/axe-core/axe.min.js\"></script>\n\
    <script src=\"script.js\"></script>\n\
    <script src=\"axe-script.js\"></script>\n\
  </body>\n\
</html>\n\
```\n\
*****\n\
```html\n\
<header>\n\
  <h1>Home Page Updated</h1>\n\
</header>\n\
*****\n\
<main>\n\
  <button id=\"btn\">Click Me</button>\n\
  <a href=\"about.html\">Go to About</a>\n\
</main>\n\
*****"


export class LLMManager {

  

  /**
   * Main class method
   * @param promptInfo: contains information needed to generate prompt, such as the 
   *  AccViolations and FileCollection to fix
   *                           
   * @returns The fixed page generated by the LLM
   */
  public async getFixes(fileCollection: FileCollection) : Promise<GeneratedFilesInfo >
  { 
    
    let cleanFileCollection: FileCollection = {}
    let fixedFileCollection: FixedFileCollection = {}
    
    for (const fileKey in fileCollection)
    {
      // get each file
      const fileData = fileCollection[fileKey]

      // console.log("fileData: " + fileData);
      cleanFileCollection[fileKey] = {
        type: fileData.type,
        content: fileData.content,
      };

      if (fileData.violationInfo === undefined || fileData.violationInfo.length == 0)
      {
        continue;
      }
      
      // create a prompt for the violation
      const template = this.promptBuilder(fileData);
      // console.log("fix template: "+ template)
      // call llm with prompt for this fix
      let output_string = ""
      output_string = await this.callLLM(template);

      // FOR TESTING
      // output_string = test_output_string;
      // console.log("output string" + output_string)
      // check files validity
      if (output_string != "" )
      {

        const chunks = output_string.split('```')
        
        // Getting updated code blocks
        let updatedCodeBlocks: string[] = []
        // console.log("chunks: " + chunks)
        let changes = chunks[3];
        // console.log("changes: " + changes)
        
        let lines = changes.split('\n');
        if (lines.length > 1) {
          // remove file type from first line and delimiter (set in callLLM) from last
          changes = lines.slice(1, -1).join('\n');
          // console.log("changes: " + changes)

          let changeArrary = changes.split("\n*****")
          for (const i in changeArrary)
          {
            updatedCodeBlocks.push(changeArrary[i])
          }
        }
        // console.log("updatedCodeBlocks: " + updatedCodeBlocks)
        
        // Get cleaned entire changed code
        output_string = chunks[1];
        // remove first and last lines, they are always just ```
        

        // first thing will be nothing, second will be entire changed code
        output_string = chunks[1];
        // remove first and last lines, they are always just ```
        lines = output_string.split('\n');
        if (lines.length <= 2) {
          continue; // if there are less than 2 lines, this return value is no good, get outta there
        }

        output_string = lines.slice(1, -1).join('\n');
        // console.log("output string clean" + output_string)

        // NEED TO ADD CHANGED LINES TO UPDATED CODE BLOCK
        fixedFileCollection[fileKey] = {
          type: fileData.type,
          content: output_string,
          updatedCodeBlocks: updatedCodeBlocks,
        };

      }
      
      // this.printFileCollection(promptInfo.files);

    }

    let generatedFileInfo : GeneratedFilesInfo = {
      originalData: cleanFileCollection,
      generatedCode: fixedFileCollection

    }
    return generatedFileInfo; 
  }

  private printFileCollection(fileCollection: Object)
  {
    for (let [key, fileData] of Object.entries(fileCollection))
    {
      console.log("fileName: " + key )
      
      if (! ("content" in fileData) || ! ("type" in fileData))
      {
        let originalFileData = fileData["originalData"]
        console.log("original file data")
        console.log("type: " + originalFileData["type"])
        console.log("content: " + originalFileData["content"])

        let generatedFileData = fileData["originalData"]
        console.log("generated file data")
        console.log("type: " + generatedFileData["type"])
        console.log("content: " + generatedFileData["content"])
      }
      else
      {
        console.log("type: " + fileData["type"])
        console.log("content: " + fileData["content"])
      }
      // if (Object.keys(value).length > 0) {
      //   this.printFileCollection(value);
      // }
    }
  }



   /**
    * Builds a prompt based on the details in the scanned report 
    * @param promptInfo 
    * @returns String of the prompt that will be used when calling the LLM
    * Assume it's only being called when fileData has violationInfo
    */
  private promptBuilder(fileData: FileData) : string 
  { 
    
      // console.log(fileData);
      let content = fileData.content
      let fileType = fileData.type
      let violationInfo = fileData.violationInfo
      if (violationInfo === undefined)
      {
        return "";
      }
      
      // console.log("fileType: " + fileType);
      // console.log("content: " + content);

      // ALSO NEED TO ERROR CHECK FOR FAILURE SUMMARY
      let failureSummary = "";
      for (const nodeIndex in violationInfo)
      {
        failureSummary += violationInfo[nodeIndex].message
      }
      // console.log("failureSummary: " + failureSummary);

      let PROMPT_TEMPLATE = `You are a helpful code assistant that can help a developer
        develop accessible web applications. 
        Using the provided context, answer the user's question 
        to the best of your ability using only the resources provided. 
        Don't explain the code, just generate the code block itself.

        I have a ${fileType} file below:
        
        ${content}

        Please fix the issues below:
        ${failureSummary}
        
        After the code block, please print each changed code snippet separated by "*****" without any additional text.
        `;
      
      // TESTING
      // const PROMPT_TEMPLATE = `You are a helpful code assistant that can help a developer
      //   develop accessible web applications. 
      //   Using the provided context, answer the user's question 
      //   to the best of your ability using only the resources provided. 
      //   Don't explain the code, just generate the code block itself.

      //   I have a ${fileType} file below:
        
      //   ${content}

      //   Return a copy of the code above`;

        // console.log("TEMPLATE: " + PROMPT_TEMPLATE)
        
        // return PROMPT_TEMPLATE;
    
    return PROMPT_TEMPLATE;
  }

  /**
   * Takes prompt returned by prompt builder, calls LLM and returns a fixed page
   * @param template 
   * @returns Page fixed based on accessibility report
   */
  // private async callLLM(template: string) : Promise<FileCollection | null> { 
  private async callLLM(template: string) : Promise<string> { 

  dotenv.config();

  const apiKey = process.env.GPT_API_TOKEN;
  const openai = new OpenAI({apiKey: apiKey});
  const stream = await openai.chat.completions.create({
    model: "gpt-4o-mini",
    messages: [{ role: "user", content: template }],
    stream: true,
  });
  let ret = "" 
  for await (const chunk of stream) {
    process.stdout.write(chunk.choices[0]?.delta?.content || "");
    ret += chunk.choices[0]?.delta?.content || ""
  }

// console.log(completion)


  // return new Promise((resolve, reject) => {
  //   exec(`python3 ${scriptPath} ${template}`, (error, stdout, stderr) => {
  //     if (error) {
  //       reject(`Error: ${error.message}`);
  //     } else if (stderr) {
  //       reject(`Stderr: ${stderr}`);
  //     } else {
  //       resolve(stdout);
  //     }
  //   });
  // });
    return ret; 
  }

  /**
   * Potential additional method to ensure that the fixes returned are valid, uses Error Handler
   * @param pageFixes 
   * @returns True if page is valid, false otherwise
   */
  private validFixedPage(pageFixes: FileCollection) : boolean { return true; }
  


}

// FOR TESTING
// REMOVE LATER

let manager = new LLMManager();
            


        
const fileCollection: FileCollection = {}
fileCollection["/index.html"] = {
  type: "html",
  content: "<!DOCTYPE html>\n  <html>\n    <head>\n      <title>Home Page Updated</title>\n      <link rel=\"stylesheet\" href=\"style.css\">\n    </head>\n    <body>\n      <h1>Home Page Updated</h1>\n      <button id=\"btn\">Click Me</button>\n      <a href=\"about.html\">Go to About</a>\n      <script src=\"node_modules/axe-core/axe.min.js\"></script>\n      <script src=\"script.js\"></script>\n      <script src=\"axe-script.js\"></script>\n    </body>\n  </html>",
  violationInfo: [
    {
      target: 'h1',
      targetCode: '<h1>Home Page Updated',
      message: 'Some page content not contained by landmarks'
    }
  ]
}

fileCollection["/style.css"] = {
  type: "css",
  content: "body { \n    font-family: Arial; \n  } \n  img { \n    width: 100px; \n  }"
};

fileCollection["/script.js"] = {
  type: "js",
  content: "document.getElementById('btn').addEventListener('click', function() {\n    alert('Updated Button Clicked!');\n  });"
};

fileCollection["/about.html"] = {
  type: "html",
  content: "<!DOCTYPE html>\n  <html>\n    <head>\n      <title>About Us</title>\n      <link rel=\"stylesheet\" href=\"about-style.css\">\n    </head>\n    <body>\n      <h1>CHANGED</h1>\n      <p>This is the about page.</p>\n      <a href=\"index.html\">Go to Home</a>\n      <script src=\"node_modules/axe-core/axe.min.js\"></script>\n      <script src=\"about-script.js\"></script>\n      <script src=\"axe-script.js\"></script>\n    </body>\n  </html>"
};

fileCollection["/about-style.css"] = {
    type: "css",
    content: "h1 { \n    color: yellow; \n  }"
};

fileCollection["/about-script.js"] = {
    type: "js",
    content: "console.log('About page loaded lglg');"
};

fileCollection["/axe-script.js"] = {
    type: "js",
    content: "\n      console.log(1);\n    import axe from 'axe-core';\n      \n    axe.run().then((results) =>\n      window.parent.postMessage({ type: 'axeResults', results }, '*')\n      );\n    "
};
fileCollection["/package.json"] = {
    type: "json",
    content: "{\n    \"name\": \"html-css-js\",\n    \"version\": \"1.0.0\",\n    \"description\": \"\",\n    \"main\": \"index.html\",\n    \"scripts\": {\n      \"start\": \"parcel index.html --open\",\n      \"build\": \"parcel build index.html\"\n    },\n    \"dependencies\": {\"axe-core\": \"^4.10.1\"},\n    \"devDependencies\": {\n      \"@babel/core\": \"7.2.0\",\n      \"parcel-bundler\": \"^1.6.1\",\n      \"axe-core\": \"^4.10.1\"\n  \n    },\n    \"keywords\": []\n  }"
};

fileCollection["/about_img.jpg"] = {
    type: "img",
    content: ""
}

let violationArray: AccViolation[] = []

violationArray.push(
  {
    pages: [
        "/index.html"
    ],
    id: "landmark-one-main",
    impact: "moderate",
    tags: [
        "cat.semantics",
        "best-practice"
    ],
    description: "Ensure the document has a main landmark",
    help: "Document should have one main landmark",
    helpUrl: "https://dequeuniversity.com/rules/axe/4.10/landmark-one-main?application=axeAPI",
    nodes: [
        {
            "any": [],
            "all": [
                {
                    "id": "page-has-main",
                    "data": null,
                    "relatedNodes": [],
                    "impact": "moderate",
                    "message": "Document does not have a main landmark"
                }
            ],
            "none": [],
            "impact": "moderate",
            "html": "<html lang=\"en\">",
            "target": [
                "html"
            ],
            failureSummary: "Fix all of the following:\n  Document does not have a main landmark"
        }
    ]
}
)

// violationArray.push(
//   {
//     pages: [],
//     id: "region",
//     impact: "moderate",
//     tags: [
//         "cat.keyboard",
//         "best-practice"
//     ],
//     description: "Ensure all page content is contained by landmarks",
//     help: "All page content should be contained by landmarks",
//     helpUrl: "https://dequeuniversity.com/rules/axe/4.10/region?application=axeAPI",
//     nodes: [
//         {
//             "any": [
//                 {
//                     "id": "region",
//                     "data": {
//                         "isIframe": false
//                     },
//                     "relatedNodes": [],
//                     "impact": "moderate",
//                     "message": "Some page content is not contained by landmarks"
//                 }
//             ],
//             "all": [],
//             "none": [],
//             "impact": "moderate",
//             "html": "<h1>Home Page Updated</h1>",
//             "target": [
//                 "h1"
//             ],
//             "failureSummary": "Fix any of the following:\n  Some page content is not contained by landmarks"
//         },
//         {
//             "any": [
//                 {
//                     "id": "region",
//                     "data": {
//                         "isIframe": false
//                     },
//                     "relatedNodes": [],
//                     "impact": "moderate",
//                     "message": "Some page content is not contained by landmarks"
//                 }
//             ],
//             "all": [],
//             "none": [],
//             "impact": "moderate",
//             "html": "<a href=\"about.html\">Go to About</a>",
//             "target": [
//                 "a"
//             ],
//             "failureSummary": "Fix any of the following:\n  Some page content is not contained by landmarks"
//         }
//     ]
// }
// )

// const llmPrompt: LlmPrompt = {
//   files: fileCollection,
//   violations: violationArray
// };

manager.getFixes(fileCollection);